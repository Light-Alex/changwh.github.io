---
layout: post
title:  "leetcode 刷题记录表"
date:   2019-09-02 16:00:00 +0800
categories: leetcode刷题实记
tags: 刷题记录表
author: ac酱
mathjax: true
---

* content
{:toc}
记录leetcode上刷题的进度，并且记录简要思路。



## check list

编号|题目|开始时间|简要思路
:-: | :-: | :-: | :-: | :-:
no.144|二叉树的前序遍历|19.09.01|递归（最简）；迭代（栈；*莫里斯遍历*）
no.94|二叉树的中序遍历|19.09.01|递归（最简）；迭代（*栈*；`莫里斯遍历`）
no.145|二叉树的后序遍历|19.09.02|递归（最简）；迭代（栈；`莫里斯遍历`）（144修改后倒序）
no.102|二叉树的层次遍历|19.09.02|`迭代（易理解、bfs、队列）；递归（dfs）`
no.104|二叉树的最大深度|19.09.07|递归（最简）；`迭代`（待整理）
no.101|对称二叉树|19.09.07|递归；迭代（栈；`bfs`（待整理））
no.112|路径总和|19.09.07|递归（全部计算后对比；每次计算后对比）；`迭代`（待整理）
no.106|从中序与后序遍历序列构造二叉树|19.09.11|递归（传递拷贝（占用过多额外内存）；传递索引）
no.105|从前序与中序遍历序列构造二叉树|19.09.11|递归（传递索引）（待整理）
no.116|填充每个节点的下一个右侧节点指针|19.09.12|迭代(BFS，使用了o(n)额外空间，不符合要求；`常量级额外空间`)；`递归`
no.117|填充每个节点的下一个右侧节点指针 II|未解决|
no.26|删除排序数组中的重复项|19.09.18|双指针覆盖/pop；倒序pop
no.122|买卖股票的最佳时机 II|19.09.19|贪心算法；真正算出哪天买哪天卖（双指针）
no.189|旋转数组|19.09.19|去尾，尾插头；切片拼接（不符题意常数级空间）；三次旋转；`环状旋转`（中兴比赛复试）
no.217|存在重复元素|19.09.20|集合去重，对比长度；字典；排序后对比连续两个元素；Counter.most_common(1)>1?
no.136|只出现一次的数字|19.09.24|*异或*；数学法；哈希表记录；列表记录
no.350|两个数组的交集 II|19.09.23|双重循环对比；排序后双指针；计数法[num1,num2]；Counter，与操作
no.66|加一|19.09.24|暴力计算；尾部对比（==9？）
no.283|移动零|19.09.24|倒序去0尾插0；覆盖后补0；双指针交换
no.1|两数之和|19.09.25|暴力解法（双重循环相加，超时）；借助字典（注意重复出现的数字，可在索引值不同时直接输出）
no.36|有效的数独|19.09.26|构造三个list进行判断；`所有相同数字的坐标存入字典中再进行判断`；`使用哈希表/list，边建表边判断`
no.48|旋转图像|19.09.27|转置后每行倒序；`旋转四个矩形（主要理解for循环的起止）`
no.344|反转字符串|19.09.29|直接交换
no.7|整数反转|19.09.29|利用list；不使用list直接整除、取模
no.387|字符串中的第一个唯一字符|19.09.29|利用Counter；find和rfind（先定义26字母的list；直接在原list上遍历）
no.242|有效的字母异位词|19.09.30|利用Counter；排序；桶记录（一个list入，一个list出）
no.125|验证回文串|19.09.30|转小写正则匹配英文数字，指针遍历；str.isalnum转小写，反转对比
no.8|字符串转换整数|19.10.08|常规解法；`正则表达式匹配`
no.28|实现strStr()|19.10.10|暴力切片对比；`Sunday`；`KMF`；`...`
no.38|外观数列|19.10.10|模拟过程；`递归`；`正则+递归`
no.14|最长公共前缀|19.10.11|纵向扫描；zip+set；字典序排序单词，比较第一个和最后一个；`分治`；`二分`；`Trie`
no.237|删除链表中的节点|19.10.11|直接删除即可
no.19|删除链表的倒数第N个节点|19.10.14|快慢指针
no.206|反转链表|19.10.14|头插法（迭代）；`递归`
no.21|合并两个有序链表|19.10.15|迭代；`递归`
no.234|回文链表|19.10.16|借助数组；快慢指针取中点，旋转后半，对比；快慢指针取中点，旋转前边，对比
no.141|环形链表|19.10.17|hash表暂存；快慢指针；置空
no.98|验证二叉搜索树|19.10.18|递归；迭代；`中序遍历迭代`；`中序遍历递归`
no.108|将有序数组转换为二叉搜索树|19.10.23|递归取中点构造二叉树
no.88|合并两个有序数组|19.10.23|新建数组，两个指针从前向后，新数组替换nums1；直接合并后排序；三指针（nums1上两个指针），从后向前
no.278|第一个错误的版本|19.10.24|从头开始循环;二分查找;`改造魔术方法+bisect模块`
no.70|爬楼梯|19.10.28|暴力递归（不使用lru_cache时超时）；带缓存递归；动态规划；类斐波拉契；斐波拉契公式；`binets`
no.121|买卖股票的最佳时机|19.10.28|取最小值和最大利润，遍历每日进行更新；暴力法（每日计算利润，超时）
no.53|最大子序和|19.10.29|动态规划；`分治法`；暴力法
no.198|打家劫舍|
no.384|打乱数组|
no.155|最小栈|
no.412|Fizz Buzz|
no.204|计数质数|
no.326|3的幂|
no.13|罗马数字转整数|
no.191|位1的个数|
no.461|汉明距离|
no.190|颠倒二进制位|
no.118|杨辉三角|
no.20|有效的括号|
no.268|缺失数字|

编号|题目|时间|简要思路
:-: | :-: | :-: | :-: | :-:
no.104|二叉树的最大深度|20.07.28|递归，返回左右子树深度的最大值+1；层次遍历；dfs
no.2|两数相加|20.07.29|各数位直接相加，记录进位，利用其中一个链表存储结果，两链表长度不同则用0补充
面试题 08.03|魔术索引|20.07.31|直接遍历；跳着遍历（i=max(i+1,nums[i])）
no.632|最小区间|20.08.01|小顶堆，有k个数组则堆中有k个元素，循环维护堆中最大值，pop最小值相减，更新范围后将最小值所在的数组的下一元素push到堆中，直至pop出的最小值所在的数组无后续元素
no.1534|统计好三元组|20.08.02|暴力法（其中一个条件提前判断，剪枝）
no.1535|找出数组游戏的赢家|20.08.02|k大等于n时即为最大值，k小于n时模拟一轮遍历进行尝试
no.1536|排布二进制网格的最少交换次数|20.08.02|先看看每一行的末尾有几个0，然后按顺序遍历每一行，当该行末尾的0的个数大于等于target时，pop掉，答案加上该行idx，target-1，重新遍历，如果全部遍历找不到大于等于target的值，返回-1
no.415|字符串相加|20.08.03|补零，记录进位，遍历结束后若进位标记=1，继续添加“1”，倒序输出
no.207|课程表|20.08.04|实质是求有向图的拓扑排序，即该图是否为有向无环图，使用bfs，先找到入度为0的节点，入队，然后依次出队，出队时将以其作为前序节点的节点的入度减一，当某个节点的入度为0时，入队，重复上述过程，直至所有节点已经遍历完毕或没有入度为0的节点，再根据遍历节点的数量进行判断；`使用dfs，以出度为切入点，首先记录临界表，遍历所有点，对每个点进行dfs遍历，记录访问情况，当遍历时访问的点的状态为搜索中时，说明图中存在环，此时返回false`
no.198|打家劫舍|20.08.05|dp，记录当前屋子打劫与否的最大值（打劫当前屋，则不能打劫前一屋）和前一屋的结果
no.213|打家劫舍Ⅱ|20.08.05|dp，分成[:-1]和[1:]两种情况分别计算，取最大值
no.337|打家劫舍Ⅲ|20.08.05|dp，类似后序遍历，递归，同时返回左右子树包含根节点和不包含根节点的值的最大值
no.1262|可被三整除的最大和|20.08.06|dp，三种状态的相互转换，注意初始化时1和2的初值都应设置为无穷小，否则在更新时会出现错误
no.100|相同的树|20.08.07|递归，两棵树同时dfs，左子树与左子树比较，右子树与右子树比较，两者相与
no.1544|整理字符串|20.08.09|暴力，遇到同字母大小写，去掉之后重新遍历，直到没有需要去除的字母；借助栈，判断当前字符与栈顶元素是否互为大小写，若是，则pop栈顶，否则将当前元素入栈，遍历结束后输出栈内字符
no.1545|找出第N个二进制字符串中的第K位|20.08.09|按题目描述暴力；递归，根据mid和k的关系，每次都进行减半，若k在前半部分则直接递归，若在后半部分则逆序后取反递归（对k进行修改）
no.1546|和为目标值的最大数目不重叠非空子数组数目|20.08.09|暴力，二维dp记录所有子数组的和，并记录与target的相同的值的起止时间，按照结束时间升序排序，类似活动安排的方法进行取舍；前缀和+贪心，遍历数组，记录数组前i项的和，存入哈希表中，如果前i项和-target的值存在于哈希表中，说明前k项到前i项的和恰好等于target值，此时重置哈希表及前i项和，答案数目+1
no.696|计数二进制子串|20.08.10|滑窗，窗口为2，当窗口中两个值不同时，分别向两端扩张，记录次数；遍历字符串，计数连续的相同字符个数，当遇到不同的字符时，重新开始计数，并且当当前计数值小于等于之前字符的计数值时，ans+1（相当于相邻的两个不同字符的个数去最小值）；查找替换“01”和“10”为“0.1”“1.0”，之后以“.”进行分割，获得每一个子串的len，ans为每两个相邻子串长度的最小值之和
no.130|被围绕的区域|20.08.11|遍历边缘的所有元素，记录“O”所在的位置，并向四个方向进行dfs或bfs遍历，并记录其中“O”的位置，最后将所有被记录的位置以外的值全部改为“X”
no.133|克隆图|20.08.12|使用dict记录每个节点的备份，使用dfs或bfs遍历整个无向图，其中dfs应该在添加neighbors时递归，bfs是依次对每个节点的相邻节点进行更新，并加入队列
no.43|字符串相乘|20.08.14|逐位相乘，记录到相应的位置，倒序遍历记录的结果，进行进位操作
no.20|有效的括号|20.08.14|使用字典记录括号的对应关系，将左括号压入栈中，遇到右括号弹出栈顶元素，检测是否匹配，不匹配或栈为空则返回false
no.733|图像渲染|20.08.18|使用栈或队列保存与当前点相邻且颜色值与初始坐标相同的四个点的坐标，不断弹出压入，直至栈或队列为空
no.109|有序链表转换二叉搜索树|20.08.18|使用快慢指针获取根节点，递归建树
no.111|二叉树的最小深度|20.08.21|dfs，判断左子树或右子树是否为0，若为0取另一子树，否则取最小值+1；bfs，队列存储节点即层数，若某节点左右子树都为空，返回该节点所在层数



`高亮`表示还需要巩固理解，巩固后若还有难度，使用*斜体*标记

**ac酱**

**to be continued**